# coding: utf-8
import logging

import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np
from scipy.spatial import Rectangle
from sklearn.manifold import MDS

import pyMOEA
def rec_dim(r):
    xy=r.mins
    w=r.maxes[0]-r.mins[0]
    h=r.maxes[1]-r.mins[1]
    return xy,w,h

def plot_res(res,problem='DTLZ2'):
    po=np.rot90(np.loadtxt("data/%s.2D.pf"%problem))

    objs=np.swapaxes(np.array(res[3][0]),0,1)
    for j,rectangles in enumerate(res[1][:-1]):
        
        fig2 = plt.figure()
        ax2 = fig2.add_subplot(111, aspect='equal')
        ax2.scatter(*res[3][1][j],c="r") # reference points
        ax2.scatter(*res[3][0][j],marker="d",c="r",zorder=5)
        ax2.scatter(objs[0][:j+1],objs[1][:j+1],marker="d",zorder=2)
        
        ax2.scatter(*list(po),alpha = 1, color = 'grey',linewidth=0,zorder=-1)
        for i,r in enumerate(rectangles):
            ax2.add_patch(patches.Rectangle(*rec_dim(r),fill=False,zorder=-2))
    plt.show()

def plot_mds(ax, values,x_limit=None,y_limit=None,**kwargs):
    """ Create MDS projection subplot of the result generated by the ADM2 

    :param matplotlib.plot.axes ax: axes to plotted on
    :param list(float) values: Values to be plotted (either referece or PO point)
    :param tuple(float,float) x_limit: Limits for x-axis (Use data if None)    
    :param tuple(float,float) y_limit: Limits for y-axis (Use data if None)    
    :param **kwargs: Arguments passed to matplotlib
    :return: Modifed ax
    :rtype matplotlib.pyplot.axes
    """
    def my_mds(m):
        return MDS(n_components=2).fit(m.astype(np.float64)).embedding_
    mds=my_mds(np.array(values))
    data=np.swapaxes(mds,0,1)
    if x_limit:
        ax.set_xlim(x_limit)
    if y_limit:
        ax.set_ylim(y_limit)
        
    # Path
    ax.plot(*data,**kwargs)
    
    # First item
    ax.scatter(data[0][0],data[1][0],zorder=4,marker='x',color="red",s=5)
    ax.scatter(*data,**kwargs)

    return ax

def show_mds(res,problem,save_file=False):
    """ Create MDS projection subplots and show them in a 2x2 grid, i.e, with maximum of 4 plots

    :param list(results) res: List of results generate by get_res
    :param str problem: Name of the problem,needed for outputs
    :param bool save_file: If true, create png of the visualization (default: False)
        
    """    
    title="%s %ik"%(problem,len(res[0][3][0][0]))
    
    fig, axes = plt.subplots(nrows=2, ncols=2)
    
    fig.suptitle(title)
    
    k=lambda i,j:plot_mds(axes[i][j],res[i*(j+1)+(j)][3][0]);
    try:
        [[k(i,j) for i in range(2)]for j in range(2)]
    except IndexError:
        pass
    if save_file:
        fig.savefig("%s.png"%title,dpi=200)
    plt.show()


def plot_contour(k,c,r):
    """  Does not work
    """
    xlist = np.linspace(0,1,10)
    ylist = np.linspace(0,10,20)
    
    X,Y = np.meshgrid(xlist,ylist)
    zlist = []
    
    for x in xlist:
    
        for y in ylist:
            
            z = pyMOEA.utility_function(0,k)
            zlist.append(z)  
    plt.figure()        
    plt.contour(X,Y,zlist)

    plt.show()  
    

def get_res(nf=2,c=None,r=.5,problem='DTLZ2',uf_n=None,**kwargs):
    problem_type=pyMOEA.problem(problem, nf)
    try:
        ideal=problem_type.ideal
        nadir=problem_type.nadir
    except AttributeError:
        ideal=[0.0]*nf
        nadir=[1.0]*nf

    init_pref=[[Rectangle(ideal,nadir)]]
    
    return pyMOEA.ADM2_solve(pyMOEA.ACH_solution,problem,init_pref,**kwargs)#,c=-np.inf)

if __name__=='__main__':
    import argparse
    parser= argparse.ArgumentParser(description="Test ADM2 Agent")
    parser.add_argument('-p','--problem', type=str,
                    help='Problem to be solved',default='External')

    parser.add_argument('-k', '--objectives', type=int,
                        help='Number of objectives',default=3)

    parser.add_argument('-n', '--runs', type=int,
                        help='Number of runs',default=1)

    parser.add_argument('-v', '--verbose', type=int,
                        help='Logging level',default=logging.INFO)

    args=parser.parse_args()    
    verbose= args.verbose
    
    
    
    logging.basicConfig(level=verbose)

    res=[]
    for i in range(args.runs):
        res.append(get_res(nf=args.objectives,problem=args.problem))
    if args.objectives==2:
        # Show only last run here
        plot_res(res[-1])
    else:
        show_mds(res,problem=args.problem)    
